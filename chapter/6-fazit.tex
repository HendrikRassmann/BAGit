\chapter{Fazit}

\paragraph{Scheduling Funktionen höherer Ordnung}
Die Sichtweise der Funktionalen Programmierung auf Scheduler ist nützlich. Sie erlaubt eine einfach Kombination verschiedener Scheduling Funktionen. Arndt et al. \cite{Arn99} haben zurecht den Backfilling Algorithmus als bevorzugten Scheduler gewählt. Jedoch lassen sich zu den meisten vorgestellten Experimenten Kombinationen der Scheduler finden, die diesen schlagen. Die Menge der möglichen Kombination ist hierbei 80, wenn zu LPT und SPT auch noch die Äquivalenten hinzu genommen werden, die die Bearbeitungszeit anstelle der Laufzeit beachten. Bei dieser Menge an Möglichkeiten ist eine qualitative Analyse wie in \cite{Arn99} oder in dieser Arbeit nicht mehr möglich. Da durch geschickte Kombinationen geringe Verbesserungen in einer Metrik im Gegenzug zu Verschlechterung in anderen Metriken erreichbar sind, müsste für so eine Untersuchung eine Gewichtung der Metriken gefunden werden. Diese könnte dann in verschiedenen Experimenten für alle Kombinationen ermittelt werden. Diese Gewichtung sollte die Drosselung einschließen.


\paragraph{Vergleich von Simulation und Testing}
Es ist unklar, wieweit die Methode des kleinsten Falles, in dem ein Algorithmus gegen gegen einen anderen die Oberhand gewinnt, für die Analyse der verschiedenen Leistungen taugt. Sicherlich ist sie ein sehr nützliches Hilfsmittel, das neue Einsichten gewähren kann. Sich schnell darüber klar werden zu können, in welchen Situation ein (ausgeklügelter) Algorithmus wie das Backfilling sich selbst überlistet, ist sicherlich eine gute Möglichkeit, die eigene Intuition weiterzuentwickeln.\\
Es ist zu beachten, dass diese Methode beinahe ohne zusätzlichen Programmieraufwand nutzbar ist. Bereits wenige Zeilen Code erlauben Einblicke in das Verhalten des Systems. Die eigentlichen Kosten dafür sind das Wählen einer ereignisorientierten Simulation. Eine prozessorientierte Sichtweise führt dazu, dass das simulierte System näher am tatsächlichen System ist. Effekte, die natürlich durch parallel agierenden Agenten entstehen, wie etwa kritische Wettlaufsituationen, treten ohne zusätzlichen Aufwand auf; ob gewünscht oder unerwünscht. Diese Effekte können durch eine zufällige Ausführungsreihenfolge mit simuliert werden, dies war allerdings nicht nötig, um vergleichbare Ergebnisse zu erzielen.

\paragraph{Reproduzierbarkeit}
Die größte Hürde  die diese Arbeit überwinden musste, stellte die Reproduzierbarkeit da. Die zugrundeliegende Theorie ist interessant, ohne übermäßig kompliziert oder unverständlich zu sein. Das Aufbauen einer äquivalenten Simulation ist ebenfalls aufwendig, aber nicht besonders anspruchsvoll. Zumal, je nach Ansatz, moderne Simulationswerkzeuge verwendet werden können, die einen großen Teil der Programmierarbeit stemmen.
Den Aufbau der Experimente nachzuvollziehen, ist allerdings bestenfalls teilweise möglich und unnötig intransparent. \\
Des Weiteren waren Arndt et al. ebenso verschiedene Versionen des Backfilling Algorithmus bekannt. Sie untersuchten die Unterschiede nicht, und verwiesen auf \cite{optVsCons}. Obwohl der darin gefundene Schluss, dass der Unterschied zwischen ''konservativem'' und ''aggressivem'' (optimistischem) Backfilling gering ist stimmt, wäre es ein Leichtes gewesen, dieses Ergebnis zu überprüfen. Der dazu befragte Artikel enthält nur Abbildungen, eine davon mit einer x-Achsen Auflösung von gerade einmal 10\%. Diese vagen Ergebnisse nebenbei zu verifizieren, hätte einen sehr geringen Aufwand dargestellt. Und es hätte sogar festgestellt werden können, dass in vielen Szenarien der gegenteilige Effekt zu beobachten ist, und das optimistische Backfilling eine bessere Leistung erzielt.

\paragraph{Weitere Untersuchungen}
Sowohl die Reproduktion als auch die Untersuchungen durch Property Based Testing würde von einer formalen Spezifikation des Systems profitieren. Eine Spezifikation, beispielsweise in \emph{TLA+} würde einen exakten Vergleich von Algorithmen auf Basis des kleinsten Gegenbeispiels ermöglichen. Gleichzeitig wäre es dadurch einfach, ein System mit dem selben Verhalten in beliebigen Programmiersprachen und Simulationsumgebungen nach zubauen.\\
Außerdem können die Experimente 1 bis 9 noch einmal mit einer praxistauglichen Gewichtung der verschiedenen Metriken untersucht werden. Die Untersuchungen der verschiedenen Algorithmen verlaufen bisher recht qualitativ. Die benutzten Parameter der Auftragszusammenstellungen sind unmotiviert, und die Gewichtung der Bedeutung der einzelnen Metriken zueinander ist unklar. Drosselung als Zielfunktion kann in die Menge der untersuchten Metriken aufgenommen werden.\\
Auch können weitere Kombinationen der Scheduler untersucht werden. Zum Beispiel wäre es interessant, FiFo mit Backfilling nach SPT oder LPT zu betreiben, um bestehende Lücken nach 'worst fit' oder 'best fit' auszufüllen.\\
Die beschriebenen Methoden des Property Based Testing lieferten interessante Ergebnisse, ob diese aber auch über die Intuitionsbildung hinaus hilfreich sind, ist noch unklar. Algorithmen nicht an konkreten Eingaben, sondern an minimalen Beispielen zu untersuchen scheint eine Vorhesagekraft zu besitzen. Diese stützt sich allerdings darauf, dass 'komplizierte' Konstellationen in Experimenten seltener auftreten als 'einfache' Konstellationen. Dies ist in den untersuchten Experimenten zwar der Fall, jedoch sind Aufträge in der Realität sicherlich selten über mehrere Eigenschaften gleichverteilt. Deshalb dürften in echten Auftragszusammenstellungen vermutlich ähnliche Konstellationen wiederholt, andere hingegen gar nicht auftreten. Generell bleibt der Wunsch nach einem besseren Modell für Auftragslisten bestehen. Weitere Anwendungen dieser Methode könnten zum Beispiel sein, für einen gegeben Algorithmus automatisiert herauszufinden, ob die Leistung monoton mit der Menge an gegebenen Informationen steigt. Falls ein Algorithmus bessere Entscheidungen trifft, wenn ein beliebiger Auftrag \textbf{später} angemeldet wird, kann untersucht werden, wie dieser verbessert werden kann. Allerdings könnten  Methoden der kleinsten Gegenbeispiele auch nützlich sein, wenn ein gutes Modell über den erwartbaren Auftragsmix besteht. Besteht so ein Modell mit entsprechenden Parametern, wäre es hilfreich herauszufinden, wie klein eine Veränderungen dieser Parameter seien kann, um den gewählten Scheduling Algorithmus durch einen anderen ersetzbar zu machen. Hierfür sollten sich allerdings klassische Optimierungsmethoden besser eignen. 