\chapter{Fazit}

\paragraph{Scheduling Funktionen höherer Ordnung}
Die Sichtweise der Funktionalen Programmierung auf Scheduler ist offensichtlich nützlich. Arndt et al. \cite{Arn99} haben zurecht den Backfilling Algorithmus als bevorzugten Scheduler gewählt. Jedoch lassen sich zu den meisten vorgestellten Experimenten Kombinationen der Scheduler finden, die diese schlagen. Die Menge der möglichen Kombination ist hierbei 80, wenn zu LPT und SPT auch noch die Äquivalenten hinzu genommen werden, die die Bearbeitungszeit anstelle der Laufzeit beachten. Bei dieser Menge an Möglichkeiten ist eine qualitative Analyse wie in \cite{Arn99} oder in dieser Arbeit nicht mehr möglich. Da durch geschickte Kombinationen geringe Verbesserungen in einer Metrik im Gegenzug zu schwerer Verschlechterung in anderen Metriken erreichbar sind, müsste für so eine Untersuchung eine Gewichtung der Metriken gefunden werden. Diese könnte dann in verschiedenen Experimenten für alle Kombinationen ermittelt werden.


\paragraph{Vergleich von Simulation und Testing}
Es ist fraglich, wieweit die Methode des kleinsten Falles, in dem ein Algorithmus gegen gegen einen anderen die Oberhand gewinnt, für die Analyse der verschiedenen Leistungen taugt. Sicherlich ist sie ein sehr nützliches Hilfsmittel, das neue Einsichten gewähren kann. Sich schnell darüber klar werden zu können, in welchen Situation ein (ausgeklügelter) Algorithmus wie das Backfilling sich selbst überlistet, ist sicherlich eine gute Möglichkeit, die eigene Intuition weiterzuentwickeln.\\
Zumal ist diese Methode beinahe ohne zusätzlichen Aufwand nutzbar. Bereits wenige Zeilen Code erlauben Einblicke in das Verhalten des Systems. Die eigentlichen Kosten dafür sind das Wählen einer ereignisorientieren Simulation. Eine prozessorientiere Sichtweise führt dazu, dass das simulierte System näher am tatsächlichen System ist. Effekte, die natürlich durch parallel agierenden Agenten entstehen, wie etwa kritische Wettlaufsituationen, treten ohne zusätzlichen Aufwand auf; ob gewünscht oder unerwünscht. Diese Effekte können durch eine zufällige Ausführungsreihenfolge mit simuliert werden, dies war allerdings nicht nötig, um vergleichbare Ergebnisse zu erzielen.

\paragraph{Reproduzierbarkeit}
Die größte Hürde dieser Arbeit stellte die fehlende Reproduzierbarkeit da. Die zugrundeliegende Theorie ist interessant, ohne übermäßig kompliziert oder unverständlich zu sein. Das Aufbauen einer äquivalenten Simulation ist ebenfalls aufwendig, aber nicht besonders anspruchsvoll. Zumal, je nach Ansatz, moderne Simulationswerkzeuge verwendet werden können, die einen großen Teil der Programmierarbeit stemmen.
Den Aufbau der Experimente nachzuvollziehen, ist allerdings bestenfalls teilweise möglich, unnötig intransparent. \\
Des Weiteren waren Arndt et al. ebenso verschiedene Versionen des Backfilling Algorithmus bekannt. Sie untersuchten die Unterschiede nicht, und verwiesen auf \cite{optVsCons}. Obwohl der darin gefundene Schluss, dass der Unterschied zwischen ''konservativem'' und ''optimistischem'' Backfilling gering wahr ist, wäre es ein Leichtes gewesen, dieses Ergebnis zu überprüfen. Der dazu befragte Artikel enthält nur Abbildungen, eine davon mit einer x-Achsen Auflösung von gerade einmal 10\%. Diese vagen Ergebnisse nebenbei mit zu verifizieren, hätte einen sehr geringen Aufwand dargestellt. Und nebenbei hätte sogar festgestellt werden, dass in den meisten Szenarien der gegenteilige Effekt zu beobachten ist, und das optimistische Backfilling eine bessere Leistung erzielt.

\paragraph{Weitere Untersuchungen}
Sowohl die Reproduktion als auch die Untersuchungen durch Property Based Testing würde von einer formalen Spezifikation des Systems profitieren. Eine Spezifikation, beispielsweise in \emph{TLA+} würde einen exakten Vergleich von Algorithmen auf Basis des kleinsten Gegenbeispiels ermöglichen. Gleichzeitig wäre es dadurch einfach, ein System mit dem selben Verhalten in beliebigen Programmiersprachen und Simulationsumgebungen nach zubauen.\\
Außerdem können die Experimente 1 bis 9 noch einmal, mit einer praxistauglichen Metrik untersucht werden. Die Untersuchungen der verschiedenen Algorithmen verlaufen bisher recht qualitativ. Die benutzten Parameter der Auftragszusammenstellungen sind unmotiviert, und die Gewichtung der Bedeutung der einzelnen Metriken zueinander ist unklar.\\
Auch können weitere Kombinationen der Scheduler untersucht werden. Zum Beispiel wäre es interessant, FiFo mit Backfilling nach LPT zu betreiben, um bestehende Lücken bestmöglich auszufüllen.\\
Die beschriebenen Methoden des Property Based Testing lieferten zwar interessante Ergebnisse, ob diese aber auch über die Intuitionsbildung hinaus hilfreich sind, ist noch unklar. Algorithmen nicht an konkreten Eingaben, sondern an minimalen Beispielen zu untersuchen scheint eine Vorhesagekraft zu besitzen. Diese stützt sich allerdings darauf, dass ''komplizierte'' Konstellationen in Experimenten seltener auftreten als ''einfache'' Konstellationen. Dies ist in den untersuchten Experimenten zwar der Fall, jedoch sind Aufträge in der Realität sicherlich selten über mehrere Eigenschaften gleichverteilt. Deshalb dürften in echten Auftragszusammenstellungen vermutlich ähnliche Konstellationen wiederholt, andere hingegen gar nicht auftreten. Generell bleibt der Wunsch nach einem besseren Modell für Auftragslisten bestehen. Allerdings könnten  Methoden der kleinsten Gegenbeispiele auch nützlich sein, wenn ein gutes Modell über den erwartbaren Auftragsmix besteht. Besteht so ein Modell mit entsprechenden Parametern, wäre es hilfreich herauszufinden, wie klein eine Veränderungen dieser Parameter seien kann, um den gewählten Scheduling Algorithmus durch einen anderen ersetzbar zu machen. Hierfür sollten sich allerdings klassische Optimierungsmethoden besser eignen. 