\chapter{Methodik}
\label{chap:ein}
\section{Problemstellung}
Notation aus \cite{Kar97}


\subsection{Auftrag (Job)}
Ein Auftrag (im Englischen "job") ist ein Prozess, der Arbeitszeit einer oder mehrerer Maschinen benötigt, um abgeschlossen zu werden. Im Folgenden werden verschieden Charakterisierungen eines Auftrags $p$ vorgestellt, nämlich seine

\begin{description}
\item[Von Schedule unabhängige Eigenschaften] \hfil \\
\textbf{Dauer} (processing time) $p_j$: Dauer die der Auftrag auf Knoten mit genormter Arbeitsgeschwindigkeit benötigt um abgeschlossen zu werden.
\textbf{Einreihung} (queueing time) $q_j$: Der Zeitpunkt, zudem ein Auftrag $j$ bekannt wird.
\textbf{Parallelität} (degree of parallelism) $\pi_j$: Die Anzahl an zugewiesenen Maschinen, die ein Auftrag benötigt, um gestartet zu werden.
\item[Durch Schedule bestimmte Eigenschaften]\hfill \\ 
\textbf{Bearbeitungsbeginn}(start time) $s_j$: Der Zeitpunkt, zudem ein Auftrag $j$ begonnen wird. 
\textbf{Abschluss}(completion time) $c_j$: Der Zeitpunkt, zudem ein Auftrag $j$ abgeschlossen wird.
\textbf{Zugewiesene Knoten} (scheduled on nodes) $n_j$: Die Menge an Knoten, auf denen ein Auftrag $j$ ausgeführt wird.

\item[Darüber hinaus] \hfil \\
können Aufträge mit zusätlichen Einschränkungen versehen werden, wie mit einen \textbf{Frühesten Bearbeitungsbeginn} (release date) $r_j$, oder mit einem \textbf{Spätesten Abschluss} (due date) $d_j$. Diese werden im Rahmen einer Simulation von voneinander unabhängigen Berechnungen nicht weiter untersucht.
\end{description}

\subsection{MachineEnv}
badbakl

Problemstellung, einleitung in Kurz

Notation aus

\section{Zielfunktionen}
Bevor verschiedene Scheduler mit einander verglichen werden können, muss zu erst festgelegt werden, mit welchem Maß gemessen werden soll. Die Ziele eines Schedulers sollten seien, Fairness zwischiden den Aufträgen zu garantieren, einen schnellen Start von Aufträgen zur ermöglichen und gleichzeittig eine hohe Auslastung der Knoten sicherzustellen. Diese Ziele sind oft unvereinbar.

\paragraph{maximum waiting time}
Die Wartezeit eines Auftrags $j$ wird defniert als die Zeitspanne zwischend Einreihung $q_j$ und Abschluss $c_j$. Die größte Wartezeit verhällt sich umgekehrt zur Fairness eines Schedulers.

\paragraph{Makespan}
Die Bearbeitungsspanne ist die vergangene Zeit zwischen dem frühsten Bearbeitungsbeginn und dem spätesten Abschluss.

\paragraph{Average Waiting Time}
Die durchschnittliche Wartezeit ist die summierte Wartezeit aller Aufträge.

\section{Scheduling Algorithmen}
Bei allen im folgenden vorgestellten Algorithmen, wird der beste Auftrag ausgewählt, wobei sich das Kriterium dafür, welcher als bester bewertet wird, unterscheided. Erfüllen mehrere Aufträge das Kriterium gleich gut, wird davon einer arbiträr ausgewählt. (Hier zitat einfügen aus lehrbuch "liste sortieren, mehrere möglichkeiten liste zu sortireren")

\paragraph{FiFo}
\textbf{First in First out} wählt zu jedem Zeitpunkt denjenigen Auftrag, der sich bereits am längsten in der Warteschlange befindet. Stehen nicht genug Knoten zur verfügung, um diesen Auftrag zu starten, müssen alle anderen Aufträge warten. FiFo minimiert. Dieses Verfahren ist zwar fair, führt allerdings zu viel ungenutzter Rechenzeit.

\paragraph{SPT}
\textbf{Shortest Processing Time first} wählt den Auftrag mit der die kürzesten angegebene Dauer. Dadurch wird versucht, die average waiting time gering zu halten. Darunter leidet die Fairness, und die maximum waiting time eines nach hinten verdrängten langen Auftrags steigt.

\paragraph{GPT}
\textbf{Greatest Processing Time first} wählt genau invers zu spt aus den Auftrag mit der längsten angegebenen Dauer. Dadurch wird der makespan zu gunsten des average flow time minimiert.

\paragraph{First Fit}
\textbf{First Fit} ist eine Abwandeelung von FiFo. Hier wird  der Auftrag, der bereits am längsten wartet und sofort gestartet werden kann, ausgewählt. Dies verringert ungenutze Rechenzeit, allerdings werden Aufträge mit einer hohen Parallelität nach hinten verdrängt.

\paragraph{Backfilling}
\textbf{Backfilling} ist eine weitere Abwandlung von FiFo. Zu erst wird der Auftrag bestimmt, der bereits am längsten wartet. Sollte dieser nicht gestartet werden können, dürfen andere Aufträge gestartet werden, vorausgesetzt, sie werden früher abgeschlossen, als der zu erst gewählte Auftrag beginnen wird. So wird ungenutzte Rechenzeit vermieden, ohne das lange große Aufträge im Vergleich zu FiFo benachteiligt werden.

\paragraph{Random}
\textbf{Random} wählt immer einen zufälligen Auftrag aus. Kann dieser nicht gestartet werden, so wird kein Auftrag gestartet.

\section{Simulation}

dasfsaefsafaefdsa

\subsection{Discrete Event Simulation}

dsafeas

\paragraph{biste diskret mann}
dsafdsafasb

\subsection{statistisch auswerten}

voll krass viel
