\chapter{Verwandte Arbeiten}
\label{chap:related_work}
In diesem Kapitel werden andere relevante Arbeiten besprochen. Es gibt eine Vielzahl von Arbeiten, die Feineinstellungen des Backfilling Algorithmus untersuchen. Allerdings wurde nur eine Quelle gefunden, die sich mit der Analyse von Optimierungsalgorithmen an Hand von minimalen Gegenbeispielen beschäftigt.

\paragraph{Testing Optimizers} von David R. MacIver \cite{TestOpt} stellt das Testen von Optimierungsfunktionen durch die Python Bibliothek \emph{Hypothesis} vor. Allerdings geht es hierbei darum festzustellen, ob ein gegebener Algorithmus ein Optimalitätskriterium erfüllt. Da in dieser Arbeit ausschließlich \emph{greedy} Algorithmen untersucht wurden, die online, also ohne vollständiges Wissen, agieren, sind die Ergebnisse nicht einfach übertragbar. Allerdings stützt dies die Tatsache, dass die Untersuchungsmethode der kleinsten Gegenbeispiele gut für Optimierungsalgorithmen anwendbar ist.

\paragraph{A comparative study of online scheduling algorithms for networks} von Olaf Arndt, Bernd Freisleben, Thilo Kielmann und Frank Thilo \cite{Arn99} stellt die Grundlage da, auf der diese Arbeit aufbaut. Darin wird ein Simulationsmodell vorgestellt, verschiedene Scheduling Algorithmen in diversen Experimenten untersucht und die Ergebnisse an einem echten Rechencluster überprüft. Backfilling Abwandlungen werden nicht betrachtet. Es wird am meisten Wert auf Bearbeitungsspanne und längster Wartezeit gelegt. Zur Überprüfung wurde eine Auftragsliste der Länge 100, aus fünf verschiedenen Programmen zusammengesetzt.

\paragraph{Utilization and predictability in scheduling the IBM SP2 with backfilling}
von Feitelson, Dror G and Weil, Ahuva Mu'alem \cite{optVsCons} vergleicht Scheduling Methoden auf einem IBM SP2 System. Optimistisches (wrtl. aggressives \cite[p. ~ 543]{optVsCons}) FiFo-Backfilling wird abgelehnt. Die Möglichkeit, für jeden Auftrag in der Warteliste vorherzusagen, wann dieser gestartet wird, wird in der Arbeit als wichtig erachtet. Es wird, auf wird kein ausschlaggebender Unterschied bezüglich der Auslastung zwischen beiden Algorithmen festgestellt. Außerdem wird eine neue Metrik vorgestellt.
Die Zielfunktion wird die \emph{durchschnittliche Drosselung} (eng. \emph{slowdown}). Dabei wird die \emph{Drosselung} eines Auftrags $j$ mit $slowdown(j) = \frac{s_j - q_j}{max(p_j,10)}$ bestimmt. Dies stellt ein Maß für Fairness da. Die Wartezeit eines Auftrags soll proportional zu seiner Bearbeitungszeit sein.


\paragraph{Attacking the bottlenecks of backfilling schedulers}
von Keleher, Peter J and Zotkin, Dmitry and Perkovic, Dejan \cite{keleher2000attacking} untersucht Abwandelungen des Backfilling Algorithmus. Auch hier wird die Drosselung zum Ziel genommen. Der im Namen der Arbeit betitelte Flaschenhals bezeichnet nicht geschlossene Lücken, die beim konservativen Backfilling auftreten können. Die Untersuchungen wurden von der kontraintuitiven Beobachtung angestoßen, dass in echten Rechenclustern verfälschte Angaben von Bearbeitungszeiten die Gesamtleistung des Systems verbessern können. Dieses Phänomen wurde weder in der Arbeit Arndt et al. \cite{Arn99} noch in dieser Arbeit festgestellt \ref{figure_8_1}. Keleher et al. schreiben dazu, dass die Bearbeitungszeit von Aufträgen in realen Situationen selten gleichverteilt ist und dass, der Anteil an langen und großen Aufträgen normalerweise relativ klein ist.\\
Es werden Abwandlungen vorgeschlagen, die das Backfilling weniger restriktiv handeln lassen. Es wird LPT-Backfilling untersucht und die gute Ausnutzung der Ressourcen gelobt. Auch wird zufälliges Auffüllen betrachtet. Zuletzt wird das optimistische Backfilling evaluiert. Auch hier wird eine messbare Leistungssteigerung vermerkt.

\paragraph{Backfilling using system-generated predictions rather than user runtime estimates} von Tsafrir, Dan und Etsion, Yoav und Feitelson, Dror G untersucht den Zusammenhang zwischen falschen Laufzeitvorhersagen und der Leistung von Backfilling.
Es wird dargelegt, dass überschätze Laufzeiten dazu führen, dass auftretende Lücken länger erscheinen, als sie sind. Dies erlaubt einem konservativen Backfilling Scheduler, aggressiver kurze Aufträge vorzuziehen. Daraus leitet sich eine erhöhte Leistung bezüglich der Drosselung ab. Es wird vorgeschlagen, Backfilling nach SPT einzusetzen. 

\cite{tsafrir2007backfilling}